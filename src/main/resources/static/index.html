<!DOCTYPE html>
<html>
<head>
    <title>1:1 WebRTC Video Chat</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        video { border: 2px solid #333; width: 48%; max-width: 600px; background: #f0f0f0; }
        .video-container { display: flex; justify-content: space-between; }
    </style>
</head>
<body>
<h1>1:1 WebRTC Video Chat</h1>
<div class="video-container">
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>
</div>

<script>
    // 1. 초기 설정
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const ws = new WebSocket("ws://175.193.199.113:8080/signal");
    let peerConnection;
    let localStream;

    // 2. WebRTC Peer Connection 설정
    const createPeerConnection = () => {
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' } // 구글의 공개 STUN 서버 사용
            ]
        });

        // ICE Candidate가 생성되면 상대방에게 전송
        pc.onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
            }
        };

        // 상대방의 스트림을 받으면 비디오 태그에 연결
        pc.ontrack = event => {
            remoteVideo.srcObject = event.streams[0];
        };

        // 로컬 스트림이 있으면 Peer Connection에 트랙 추가
        if (localStream) {
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
        }

        return pc;
    };

    // 3. WebSocket 메시지 핸들링
    ws.onmessage = async event => {
        const message = JSON.parse(event.data);

        if (!peerConnection && (message.type === 'offer' || message.type === 'answer')) {
            peerConnection = createPeerConnection();
        }

        switch (message.type) {
            case 'offer':
                console.log("Received Offer...");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                ws.send(JSON.stringify({ type: 'answer', answer: answer }));
                break;
            case 'answer':
                console.log("Received Answer...");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                break;
            case 'candidate':
                console.log("Received ICE Candidate...");
                await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                break;
            case 'start': // 상대방이 접속했을 때 서버가 보내주는 커스텀 메시지 (여기서는 2번째 접속자가 offer를 보내도록 트리거)
                console.log("Peer connected, creating offer...");
                peerConnection = createPeerConnection();
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                ws.send(JSON.stringify({ type: 'offer', offer: offer }));
                break;
        }
    };

    // 4. 로컬 미디어 스트림 시작
    const startMedia = async () => {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
        } catch (error) {
            console.error("Error accessing media devices.", error);
        }
    };

    // WebSocket 연결이 성공하면 미디어 시작
    ws.onopen = () => {
        console.log("Connected to the signaling server");
        startMedia();
    };

</script>
</body>
</html>